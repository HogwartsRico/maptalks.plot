{"version":3,"file":"maptalks.plot.js","sources":["../src/core/PlotTypes.js","../src/geometry/Polyline/Curve.js","../src/geometry/Polyline/Polyline.js","../src/geometry/index.js","../src/utils/utils.js","../src/core/PlotDraw.js"],"sourcesContent":["/**\n * Created by FDD on 2017/5/20.\n */\nconst TextArea = 'TextArea' // 文本标绘（特殊）\nconst ARC = 'Arc'\nconst CURVE = 'Curve'\nconst GATHERING_PLACE = 'GatheringPlace'\nconst POLYLINE = 'Polyline'\nconst FREE_LINE = 'FreeLine'\nconst POINT = 'Point'\nconst PENNANT = 'Pennant'\nconst RECTANGLE = 'RectAngle'\nconst CIRCLE = 'Circle'\nconst ELLIPSE = 'Ellipse'\nconst LUNE = 'Lune'\nconst SECTOR = 'Sector'\nconst CLOSED_CURVE = 'ClosedCurve'\nconst POLYGON = 'Polygon'\nconst FREE_POLYGON = 'FreePolygon'\nconst ATTACK_ARROW = 'AttackArrow'\nconst DOUBLE_ARROW = 'DoubleArrow'\nconst STRAIGHT_ARROW = 'StraightArrow'\nconst FINE_ARROW = 'FineArrow'\nconst ASSAULT_DIRECTION = 'AssaultDirection'\nconst TAILED_ATTACK_ARROW = 'TailedAttackArrow'\nconst SQUAD_COMBAT = 'SquadCombat'\nconst TAILED_SQUAD_COMBAT = 'TailedSquadCombat'\nconst RECTFLAG = 'RectFlag'\nconst TRIANGLEFLAG = 'TriangleFlag'\nconst CURVEFLAG = 'CurveFlag'\nexport {\n  TextArea,\n  ARC,\n  CURVE,\n  GATHERING_PLACE,\n  POLYLINE,\n  FREE_LINE,\n  POINT,\n  PENNANT,\n  RECTANGLE,\n  CIRCLE,\n  ELLIPSE,\n  LUNE,\n  SECTOR,\n  CLOSED_CURVE,\n  POLYGON,\n  FREE_POLYGON,\n  ATTACK_ARROW,\n  DOUBLE_ARROW,\n  STRAIGHT_ARROW,\n  FINE_ARROW,\n  ASSAULT_DIRECTION,\n  TAILED_SQUAD_COMBAT,\n  TAILED_ATTACK_ARROW,\n  SQUAD_COMBAT,\n  RECTFLAG,\n  TRIANGLEFLAG,\n  CURVEFLAG\n}\n","/**\n * Created by FDD on 2017/12/10.\n * @desc 标绘曲线算法\n */\n\nimport * as maptalks from 'maptalks'\nconst Canvas2d = maptalks.Canvas\nconst options = {\n  'arcDegree': 90\n}\nclass Curve extends maptalks.LineString {\n  _arc (ctx, points, lineOpacity) {\n    const degree = this.options['arcDegree'] * Math.PI / 180\n    for (let i = 1, l = points.length; i < l; i++) {\n      Canvas2d._arcBetween(ctx, points[i - 1], points[i], degree)\n      Canvas2d._stroke(ctx, lineOpacity)\n    }\n  }\n\n  _quadraticCurve (ctx, points) {\n    if (points.length <= 2) {\n      Canvas2d._path(ctx, points)\n      return\n    }\n    Canvas2d.quadraticCurve(ctx, points)\n  }\n\n  _bezierCurve (ctx, points) {\n    if (points.length <= 3) {\n      Canvas2d._path(ctx, points)\n      return\n    }\n    let i, l\n    for (i = 1, l = points.length; i + 2 < l; i += 3) {\n      ctx.bezierCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y)\n    }\n    if (i < l) {\n      for (; i < l; i++) {\n        ctx.lineTo(points[i].x, points[i].y)\n      }\n    }\n  }\n\n  _toJSON (options) {\n    return {\n      'feature': this.toGeoJSON(options),\n      'subType': 'Curve'\n    }\n  }\n\n  // paint method on canvas\n  _paintOn (ctx, points, lineOpacity) {\n    ctx.beginPath()\n    this._arc(ctx, points, lineOpacity)\n    Canvas2d._stroke(ctx, lineOpacity)\n    this._paintArrow(ctx, points, lineOpacity)\n  }\n\n  static fromJSON (json) {\n    const feature = json['feature']\n    const arc = new Curve(feature['geometry']['coordinates'], json['options'])\n    arc.setProperties(feature['properties'])\n    return arc\n  }\n}\nCurve.registerJSONType('Curve')\nCurve.mergeOptions(options)\n\nexport default Curve\n","import * as maptalks from 'maptalks'\nconst Coordinate = maptalks.Coordinate\nconst options = {\n  'arrowStyle': null,\n  'arrowPlacement': 'vertex-last', // vertex-first, vertex-last, vertex-firstlast, point\n  'clipToPaint': true\n}\n\nclass Polyline extends maptalks.LineString {\n  constructor (coordinates, options = {}) {\n    super(options)\n    this.type = 'Polyline'\n    if (coordinates) {\n      this.setCoordinates(coordinates)\n    }\n  }\n\n  _exportGeoJSONGeometry () {\n    const points = this.getCoordinates()\n    const coordinates = Coordinate.toNumberArrays(points)\n    return {\n      'type': 'LineString',\n      'coordinates': coordinates\n    }\n  }\n\n  _toJSON (options) {\n    return {\n      'feature': this.toGeoJSON(options)\n    }\n  }\n}\n\nPolyline.mergeOptions(options)\n\nPolyline.registerJSONType('Polyline')\n\nexport default Polyline\n","/**\n * Created by FDD on 2017/5/20.\n * @desc 标绘图形构造类\n */\n\nimport Curve from './Polyline/Curve'\nimport Polyline from './Polyline/Polyline'\nimport * as PlotTypes from '../core/PlotTypes'\nconst RegisterModes = {}\nRegisterModes[PlotTypes.CURVE] = {\n  'action': 'clickDblclick',\n  'create': function (path) {\n    return new Curve(path)\n  },\n  'update': function (path, geometry) {\n    geometry.setCoordinates(path)\n  },\n  'generate': function (geometry) {\n    return geometry\n  }\n}\nRegisterModes[PlotTypes.POLYLINE] = {\n  'action': 'clickDblclick',\n  'create': function (path) {\n    return new Polyline(path)\n  },\n  'update': function (path, geometry) {\n    geometry.setCoordinates(path)\n  },\n  'generate': function (geometry) {\n    return geometry\n  }\n}\nexport default RegisterModes\n","import * as Constants from '../Constants'\n/**\n * 计算两个坐标之间的距离\n * @param pnt1\n * @param pnt2\n * @returns {number}\n * @constructor\n */\nexport const MathDistance = (pnt1, pnt2) => {\n  return (Math.sqrt(Math.pow((pnt1[0] - pnt2[0]), 2) + Math.pow((pnt1[1] - pnt2[1]), 2)))\n}\n\n/**\n * 计算点集合的总距离\n * @param points\n * @returns {number}\n */\nexport const wholeDistance = (points) => {\n  let distance = 0\n  if (points && Array.isArray(points) && points.length > 0) {\n    points.forEach((item, index) => {\n      if (index < points.length - 1) {\n        distance += (MathDistance(item, points[index + 1]))\n      }\n    })\n  }\n  return distance\n}\n/**\n * 获取基础长度\n * @param points\n * @returns {number}\n */\nexport const getBaseLength = (points) => {\n  return Math.pow(wholeDistance(points), 0.99)\n}\n\n/**\n * 求取两个坐标的中间值\n * @param point1\n * @param point2\n * @returns {[*,*]}\n * @constructor\n */\nexport const Mid = (point1, point2) => {\n  return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2]\n}\n\n/**\n * 通过三个点确定一个圆的中心点\n * @param point1\n * @param point2\n * @param point3\n */\nexport const getCircleCenterOfThreePoints = (point1, point2, point3) => {\n  let pntA = [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2]\n  let pntB = [pntA[0] - point1[1] + point2[1], pntA[1] + point1[0] - point2[0]]\n  let pntC = [(point1[0] + point3[0]) / 2, (point1[1] + point3[1]) / 2]\n  let pntD = [pntC[0] - point1[1] + point3[1], pntC[1] + point1[0] - point3[0]]\n  return getIntersectPoint(pntA, pntB, pntC, pntD)\n}\n\n/**\n * 获取交集的点\n * @param pntA\n * @param pntB\n * @param pntC\n * @param pntD\n * @returns {[*,*]}\n */\nexport const getIntersectPoint = (pntA, pntB, pntC, pntD) => {\n  if (pntA[1] === pntB[1]) {\n    let f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1])\n    let x = f * (pntA[1] - pntC[1]) + pntC[0]\n    let y = pntA[1]\n    return [x, y]\n  }\n  if (pntC[1] === pntD[1]) {\n    let e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1])\n    let x = e * (pntC[1] - pntA[1]) + pntA[0]\n    let y = pntC[1]\n    return [x, y]\n  }\n  let e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1])\n  let f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1])\n  let y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f)\n  let x = e * y - e * pntA[1] + pntA[0]\n  return [x, y]\n}\n\n/**\n * 获取方位角（地平经度）\n * @param startPoint\n * @param endPoint\n * @returns {*}\n */\nexport const getAzimuth = (startPoint, endPoint) => {\n  let azimuth\n  let angle = Math.asin(Math.abs(endPoint[1] - startPoint[1]) / (MathDistance(startPoint, endPoint)))\n  if (endPoint[1] >= startPoint[1] && endPoint[0] >= startPoint[0]) {\n    azimuth = angle + Math.PI\n  } else if (endPoint[1] >= startPoint[1] && endPoint[0] < startPoint[0]) {\n    azimuth = Math.PI * 2 - angle\n  } else if (endPoint[1] < startPoint[1] && endPoint[0] < startPoint[0]) {\n    azimuth = angle\n  } else if (endPoint[1] < startPoint[1] && endPoint[0] >= startPoint[0]) {\n    azimuth = Math.PI - angle\n  }\n  return azimuth\n}\n\n/**\n * 通过三个点获取方位角\n * @param pntA\n * @param pntB\n * @param pntC\n * @returns {number}\n */\nexport const getAngleOfThreePoints = (pntA, pntB, pntC) => {\n  let angle = getAzimuth(pntB, pntA) - getAzimuth(pntB, pntC)\n  return ((angle < 0) ? (angle + Math.PI * 2) : angle)\n}\n\n/**\n * 判断是否是顺时针\n * @param pnt1\n * @param pnt2\n * @param pnt3\n * @returns {boolean}\n */\nexport const isClockWise = (pnt1, pnt2, pnt3) => {\n  return ((pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]))\n}\n\n/**\n * 获取线上的点\n * @param t\n * @param startPnt\n * @param endPnt\n * @returns {[*,*]}\n */\nexport const getPointOnLine = (t, startPnt, endPnt) => {\n  let x = startPnt[0] + (t * (endPnt[0] - startPnt[0]))\n  let y = startPnt[1] + (t * (endPnt[1] - startPnt[1]))\n  return [x, y]\n}\n\n/**\n * 获取立方值\n * @param t\n * @param startPnt\n * @param cPnt1\n * @param cPnt2\n * @param endPnt\n * @returns {[*,*]}\n */\nexport const getCubicValue = (t, startPnt, cPnt1, cPnt2, endPnt) => {\n  t = Math.max(Math.min(t, 1), 0)\n  let [tp, t2] = [(1 - t), (t * t)]\n  let t3 = t2 * t\n  let tp2 = tp * tp\n  let tp3 = tp2 * tp\n  let x = (tp3 * startPnt[0]) + (3 * tp2 * t * cPnt1[0]) + (3 * tp * t2 * cPnt2[0]) + (t3 * endPnt[0])\n  let y = (tp3 * startPnt[1]) + (3 * tp2 * t * cPnt1[1]) + (3 * tp * t2 * cPnt2[1]) + (t3 * endPnt[1])\n  return [x, y]\n}\n\n/**\n * 根据起止点和旋转方向求取第三个点\n * @param startPnt\n * @param endPnt\n * @param angle\n * @param distance\n * @param clockWise\n * @returns {[*,*]}\n */\nexport const getThirdPoint = (startPnt, endPnt, angle, distance, clockWise) => {\n  let azimuth = getAzimuth(startPnt, endPnt)\n  let alpha = clockWise ? (azimuth + angle) : (azimuth - angle)\n  let dx = distance * Math.cos(alpha)\n  let dy = distance * Math.sin(alpha)\n  return ([endPnt[0] + dx, endPnt[1] + dy])\n}\n\n/**\n * 插值弓形线段点\n * @param center\n * @param radius\n * @param startAngle\n * @param endAngle\n * @returns {null}\n */\nexport const getArcPoints = (center, radius, startAngle, endAngle) => {\n  let [x, y, pnts, angleDiff] = [null, null, [], (endAngle - startAngle)]\n  angleDiff = ((angleDiff < 0) ? (angleDiff + (Math.PI * 2)) : angleDiff)\n  for (let i = 0; i <= 100; i++) {\n    let angle = startAngle + angleDiff * i / 100\n    x = center[0] + radius * Math.cos(angle)\n    y = center[1] + radius * Math.sin(angle)\n    pnts.push([x, y])\n  }\n  return pnts\n}\n\n/**\n * getBisectorNormals\n * @param t\n * @param pnt1\n * @param pnt2\n * @param pnt3\n * @returns {[*,*]}\n */\nexport const getBisectorNormals = (t, pnt1, pnt2, pnt3) => {\n  let normal = getNormal(pnt1, pnt2, pnt3)\n  let [bisectorNormalRight, bisectorNormalLeft, dt, x, y] = [null, null, null, null, null]\n  let dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1])\n  let uX = normal[0] / dist\n  let uY = normal[1] / dist\n  let d1 = MathDistance(pnt1, pnt2)\n  let d2 = MathDistance(pnt2, pnt3)\n  if (dist > Constants.ZERO_TOLERANCE) {\n    if (isClockWise(pnt1, pnt2, pnt3)) {\n      dt = t * d1\n      x = pnt2[0] - dt * uY\n      y = pnt2[1] + dt * uX\n      bisectorNormalRight = [x, y]\n      dt = t * d2\n      x = pnt2[0] + dt * uY\n      y = pnt2[1] - dt * uX\n      bisectorNormalLeft = [x, y]\n    } else {\n      dt = t * d1\n      x = pnt2[0] + dt * uY\n      y = pnt2[1] - dt * uX\n      bisectorNormalRight = [x, y]\n      dt = t * d2\n      x = pnt2[0] - dt * uY\n      y = pnt2[1] + dt * uX\n      bisectorNormalLeft = [x, y]\n    }\n  } else {\n    x = pnt2[0] + t * (pnt1[0] - pnt2[0])\n    y = pnt2[1] + t * (pnt1[1] - pnt2[1])\n    bisectorNormalRight = [x, y]\n    x = pnt2[0] + t * (pnt3[0] - pnt2[0])\n    y = pnt2[1] + t * (pnt3[1] - pnt2[1])\n    bisectorNormalLeft = [x, y]\n  }\n  return [bisectorNormalRight, bisectorNormalLeft]\n}\n\n/**\n * 获取默认三点的内切圆\n * @param pnt1\n * @param pnt2\n * @param pnt3\n * @returns {[*,*]}\n */\nexport const getNormal = (pnt1, pnt2, pnt3) => {\n  let dX1 = pnt1[0] - pnt2[0]\n  let dY1 = pnt1[1] - pnt2[1]\n  let d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1)\n  dX1 /= d1\n  dY1 /= d1\n  let dX2 = pnt3[0] - pnt2[0]\n  let dY2 = pnt3[1] - pnt2[1]\n  let d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2)\n  dX2 /= d2\n  dY2 /= d2\n  let uX = dX1 + dX2\n  let uY = dY1 + dY2\n  return [uX, uY]\n}\n\n/**\n * 获取左边控制点\n * @param controlPoints\n * @returns {[*,*]}\n */\nexport const getLeftMostControlPoint = (controlPoints, t) => {\n  let [pnt1, pnt2, pnt3, controlX, controlY] = [controlPoints[0], controlPoints[1], controlPoints[2], null, null]\n  let pnts = getBisectorNormals(0, pnt1, pnt2, pnt3)\n  let normalRight = pnts[0]\n  let normal = getNormal(pnt1, pnt2, pnt3)\n  let dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1])\n  if (dist > Constants.ZERO_TOLERANCE) {\n    let mid = Mid(pnt1, pnt2)\n    let pX = pnt1[0] - mid[0]\n    let pY = pnt1[1] - mid[1]\n    let d1 = MathDistance(pnt1, pnt2)\n    let n = 2.0 / d1\n    let nX = -n * pY\n    let nY = n * pX\n    let a11 = nX * nX - nY * nY\n    let a12 = 2 * nX * nY\n    let a22 = nY * nY - nX * nX\n    let dX = normalRight[0] - mid[0]\n    let dY = normalRight[1] - mid[1]\n    controlX = mid[0] + a11 * dX + a12 * dY\n    controlY = mid[1] + a12 * dX + a22 * dY\n  } else {\n    controlX = pnt1[0] + t * (pnt2[0] - pnt1[0])\n    controlY = pnt1[1] + t * (pnt2[1] - pnt1[1])\n  }\n  return [controlX, controlY]\n}\n\n/**\n * 获取右边控制点\n * @param controlPoints\n * @param t\n * @returns {[*,*]}\n */\nexport const getRightMostControlPoint = (controlPoints, t) => {\n  let count = controlPoints.length\n  let pnt1 = controlPoints[count - 3]\n  let pnt2 = controlPoints[count - 2]\n  let pnt3 = controlPoints[count - 1]\n  let pnts = getBisectorNormals(0, pnt1, pnt2, pnt3)\n  let normalLeft = pnts[1]\n  let normal = getNormal(pnt1, pnt2, pnt3)\n  let dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1])\n  let [controlX, controlY] = [null, null]\n  if (dist > Constants.ZERO_TOLERANCE) {\n    let mid = Mid(pnt2, pnt3)\n    let pX = pnt3[0] - mid[0]\n    let pY = pnt3[1] - mid[1]\n    let d1 = MathDistance(pnt2, pnt3)\n    let n = 2.0 / d1\n    let nX = -n * pY\n    let nY = n * pX\n    let a11 = nX * nX - nY * nY\n    let a12 = 2 * nX * nY\n    let a22 = nY * nY - nX * nX\n    let dX = normalLeft[0] - mid[0]\n    let dY = normalLeft[1] - mid[1]\n    controlX = mid[0] + a11 * dX + a12 * dY\n    controlY = mid[1] + a12 * dX + a22 * dY\n  } else {\n    controlX = pnt3[0] + t * (pnt2[0] - pnt3[0])\n    controlY = pnt3[1] + t * (pnt2[1] - pnt3[1])\n  }\n  return [controlX, controlY]\n}\n\n/**\n * 插值曲线点\n * @param t\n * @param controlPoints\n * @returns {null}\n */\nexport const getCurvePoints = (t, controlPoints) => {\n  let leftControl = getLeftMostControlPoint(controlPoints, t)\n  let [pnt1, pnt2, pnt3, normals, points] = [null, null, null, [leftControl], []]\n  for (let i = 0; i < controlPoints.length - 2; i++) {\n    [pnt1, pnt2, pnt3] = [controlPoints[i], controlPoints[i + 1], controlPoints[i + 2]]\n    let normalPoints = getBisectorNormals(t, pnt1, pnt2, pnt3)\n    normals = normals.concat(normalPoints)\n  }\n  let rightControl = getRightMostControlPoint(controlPoints, t)\n  if (rightControl) {\n    normals.push(rightControl)\n  }\n  for (let i = 0; i < controlPoints.length - 1; i++) {\n    pnt1 = controlPoints[i]\n    pnt2 = controlPoints[i + 1]\n    points.push(pnt1)\n    for (let t = 0; t < Constants.FITTING_COUNT; t++) {\n      let pnt = getCubicValue(t / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2)\n      points.push(pnt)\n    }\n    points.push(pnt2)\n  }\n  return points\n}\n\n/**\n * 贝塞尔曲线\n * @param points\n * @returns {*}\n */\nexport const getBezierPoints = function (points) {\n  if (points.length <= 2) {\n    return points\n  } else {\n    let bezierPoints = []\n    let n = points.length - 1\n    for (let t = 0; t <= 1; t += 0.01) {\n      let [x, y] = [0, 0]\n      for (let index = 0; index <= n; index++) {\n        let factor = getBinomialFactor(n, index)\n        let a = Math.pow(t, index)\n        let b = Math.pow((1 - t), (n - index))\n        x += factor * a * b * points[index][0]\n        y += factor * a * b * points[index][1]\n      }\n      bezierPoints.push([x, y])\n    }\n    bezierPoints.push(points[n])\n    return bezierPoints\n  }\n}\n\n/**\n * 获取阶乘数据\n * @param n\n * @returns {number}\n */\nexport const getFactorial = (n) => {\n  let result = 1\n  switch (n) {\n    case (n <= 1):\n      result = 1\n      break\n    case (n === 2):\n      result = 2\n      break\n    case (n === 3):\n      result = 6\n      break\n    case (n === 24):\n      result = 24\n      break\n    case (n === 5):\n      result = 120\n      break\n    default:\n      for (let i = 1; i <= n; i++) {\n        result *= i\n      }\n      break\n  }\n  return result\n}\n\n/**\n * 获取二项分布\n * @param n\n * @param index\n * @returns {number}\n */\nexport const getBinomialFactor = (n, index) => {\n  return (getFactorial(n) / (getFactorial(index) * getFactorial(n - index)))\n}\n\n/**\n * 插值线性点\n * @param points\n * @returns {*}\n */\nexport const getQBSplinePoints = points => {\n  if (points.length <= 2) {\n    return points\n  } else {\n    let [n, bSplinePoints] = [2, []]\n    let m = points.length - n - 1\n    bSplinePoints.push(points[0])\n    for (let i = 0; i <= m; i++) {\n      for (let t = 0; t <= 1; t += 0.05) {\n        let [x, y] = [0, 0]\n        for (let k = 0; k <= n; k++) {\n          let factor = getQuadricBSplineFactor(k, t)\n          x += factor * points[i + k][0]\n          y += factor * points[i + k][1]\n        }\n        bSplinePoints.push([x, y])\n      }\n    }\n    bSplinePoints.push(points[points.length - 1])\n    return bSplinePoints\n  }\n}\n\n/**\n * 得到二次线性因子\n * @param k\n * @param t\n * @returns {number}\n */\nexport const getQuadricBSplineFactor = (k, t) => {\n  let res = 0\n  if (k === 0) {\n    res = Math.pow(t - 1, 2) / 2\n  } else if (k === 1) {\n    res = (-2 * Math.pow(t, 2) + 2 * t + 1) / 2\n  } else if (k === 2) {\n    res = Math.pow(t, 2) / 2\n  }\n  return res\n}\n\n/**\n * 判断是否为对象\n * @param value\n * @returns {boolean}\n */\nexport const isObject = value => {\n  const type = typeof value\n  return value !== null && (type === 'object' || type === 'function')\n}\n\nexport const merge = (a, b) => {\n  for (const key in b) {\n    if (isObject(b[key]) && isObject(a[key])) {\n      merge(a[key], b[key])\n    } else {\n      a[key] = b[key]\n    }\n  }\n  return a\n}\n","/**\n * Created by FDD on 2017/12/10.\n * @desc PlotDraw\n */\n\nimport * as maptalks from 'maptalks'\nimport RegisterModes from '../geometry'\nimport { merge } from '../utils/utils'\nconst _options = {\n  'symbol': {\n    'lineColor': '#000',\n    'lineWidth': 2,\n    'lineOpacity': 1,\n    'polygonFill': '#fff',\n    'polygonOpacity': 0.3\n  },\n  'doubleClickZoom': false,\n  'mode': null,\n  'once': false,\n  'ignoreMouseleave': true\n}\nconst registeredMode = {}\nclass PlotDraw extends maptalks.DrawTool {\n  constructor (options = {}) {\n    const $options = merge(_options, options)\n    super($options)\n    this.options = $options\n    this._checkMode()\n  }\n\n  _getRegisterMode () {\n    const mode = this.getMode()\n    const registerMode = PlotDraw.getRegisterMode(mode)\n    if (!registerMode) {\n      throw new Error(mode + ' is not a valid mode of DrawTool.')\n    }\n    return registerMode\n  }\n\n  /**\n   * Set draw tool's symbol\n   * @param {Object} symbol - symbol set\n   * @returns {DrawTool} this\n   */\n  setSymbol (symbol) {\n    if (!symbol) {\n      return this\n    }\n    this.options['symbol'] = symbol\n    if (this._geometry) {\n      this._geometry.setSymbol(symbol)\n    }\n    return this\n  }\n\n  /**\n   * Register a new mode for DrawTool\n   * @param name\n   * @param modeAction\n   */\n  static registerMode (name, modeAction) {\n    registeredMode[name.toLowerCase()] = modeAction\n  }\n\n  /**\n   * Get mode actions by mode name\n   * @param  {String} name DrawTool mode name\n   * @return {Object}      mode actions\n   */\n  static getRegisterMode (name) {\n    return registeredMode[name.toLowerCase()]\n  }\n\n  /**\n   * Register modes for DrawTool\n   * @param modes\n   */\n  static registeredModes (modes) {\n    if (modes) {\n      for (let key of Reflect.ownKeys(modes)) {\n        if (!key.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)) {\n          let desc = Object.getOwnPropertyDescriptor(modes, key)\n          let _key = key.toLowerCase()\n          Object.defineProperty(registeredMode, _key, desc)\n          console.log(registeredMode)\n        }\n      }\n    }\n  }\n}\n\nPlotDraw.registeredModes(RegisterModes)\n\nexport default PlotDraw\n"],"names":["TextArea","ARC","CURVE","GATHERING_PLACE","POLYLINE","FREE_LINE","POINT","PENNANT","RECTANGLE","CIRCLE","ELLIPSE","LUNE","SECTOR","CLOSED_CURVE","POLYGON","FREE_POLYGON","ATTACK_ARROW","DOUBLE_ARROW","STRAIGHT_ARROW","FINE_ARROW","ASSAULT_DIRECTION","TAILED_ATTACK_ARROW","SQUAD_COMBAT","TAILED_SQUAD_COMBAT","RECTFLAG","TRIANGLEFLAG","CURVEFLAG","Canvas2d","maptalks","options","Curve","_arc","ctx","points","lineOpacity","degree","Math","PI","i","l","length","_arcBetween","_stroke","_quadraticCurve","_path","quadraticCurve","_bezierCurve","bezierCurveTo","x","y","lineTo","_toJSON","toGeoJSON","_paintOn","beginPath","_paintArrow","fromJSON","json","feature","arc","setProperties","registerJSONType","mergeOptions","Coordinate","Polyline","coordinates","type","setCoordinates","_exportGeoJSONGeometry","getCoordinates","toNumberArrays","RegisterModes","PlotTypes","path","geometry","isObject","value","merge","a","b","key","_options","registeredMode","PlotDraw","$options","_checkMode","_getRegisterMode","mode","getMode","registerMode","getRegisterMode","Error","setSymbol","symbol","_geometry","name","modeAction","toLowerCase","registeredModes","modes","Reflect","ownKeys","match","desc","Object","getOwnPropertyDescriptor","_key","defineProperty","log"],"mappings":"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"}