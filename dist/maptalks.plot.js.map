{"version":3,"file":"maptalks.plot.js","sources":["../src/core/PlotTypes.js","../src/geometry/Polyline/Curve.js","../src/geometry/Polyline/Polyline.js","../src/geometry/Polyline/FreeLine.js","../src/geometry/index.js","../src/utils/utils.js","../src/core/PlotDraw.js"],"sourcesContent":["/**\n * Created by FDD on 2017/5/20.\n */\nconst TextArea = 'TextArea' // 文本标绘（特殊）\nconst ARC = 'Arc'\nconst CURVE = 'Curve'\nconst GATHERING_PLACE = 'GatheringPlace'\nconst POLYLINE = 'Polyline'\nconst FREE_LINE = 'FreeLine'\nconst POINT = 'Point'\nconst PENNANT = 'Pennant'\nconst RECTANGLE = 'RectAngle'\nconst CIRCLE = 'Circle'\nconst ELLIPSE = 'Ellipse'\nconst LUNE = 'Lune'\nconst SECTOR = 'Sector'\nconst CLOSED_CURVE = 'ClosedCurve'\nconst POLYGON = 'Polygon'\nconst FREE_POLYGON = 'FreePolygon'\nconst ATTACK_ARROW = 'AttackArrow'\nconst DOUBLE_ARROW = 'DoubleArrow'\nconst STRAIGHT_ARROW = 'StraightArrow'\nconst FINE_ARROW = 'FineArrow'\nconst ASSAULT_DIRECTION = 'AssaultDirection'\nconst TAILED_ATTACK_ARROW = 'TailedAttackArrow'\nconst SQUAD_COMBAT = 'SquadCombat'\nconst TAILED_SQUAD_COMBAT = 'TailedSquadCombat'\nconst RECTFLAG = 'RectFlag'\nconst TRIANGLEFLAG = 'TriangleFlag'\nconst CURVEFLAG = 'CurveFlag'\nexport {\n  TextArea,\n  ARC,\n  CURVE,\n  GATHERING_PLACE,\n  POLYLINE,\n  FREE_LINE,\n  POINT,\n  PENNANT,\n  RECTANGLE,\n  CIRCLE,\n  ELLIPSE,\n  LUNE,\n  SECTOR,\n  CLOSED_CURVE,\n  POLYGON,\n  FREE_POLYGON,\n  ATTACK_ARROW,\n  DOUBLE_ARROW,\n  STRAIGHT_ARROW,\n  FINE_ARROW,\n  ASSAULT_DIRECTION,\n  TAILED_SQUAD_COMBAT,\n  TAILED_ATTACK_ARROW,\n  SQUAD_COMBAT,\n  RECTFLAG,\n  TRIANGLEFLAG,\n  CURVEFLAG\n}\n","/**\n * Created by FDD on 2017/12/10.\n * @desc 标绘曲线算法\n */\n\nimport * as maptalks from 'maptalks'\nconst Canvas2d = maptalks.Canvas\nconst options = {\n  'arcDegree': 90\n}\nclass Curve extends maptalks.LineString {\n  _arc (ctx, points, lineOpacity) {\n    const degree = this.options['arcDegree'] * Math.PI / 180\n    for (let i = 1, l = points.length; i < l; i++) {\n      Canvas2d._arcBetween(ctx, points[i - 1], points[i], degree)\n      Canvas2d._stroke(ctx, lineOpacity)\n    }\n  }\n\n  _quadraticCurve (ctx, points) {\n    if (points.length <= 2) {\n      Canvas2d._path(ctx, points)\n      return\n    }\n    Canvas2d.quadraticCurve(ctx, points)\n  }\n\n  _bezierCurve (ctx, points) {\n    if (points.length <= 3) {\n      Canvas2d._path(ctx, points)\n      return\n    }\n    let i, l\n    for (i = 1, l = points.length; i + 2 < l; i += 3) {\n      ctx.bezierCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y)\n    }\n    if (i < l) {\n      for (; i < l; i++) {\n        ctx.lineTo(points[i].x, points[i].y)\n      }\n    }\n  }\n\n  _toJSON (options) {\n    return {\n      'feature': this.toGeoJSON(options),\n      'subType': 'Curve'\n    }\n  }\n\n  // paint method on canvas\n  _paintOn (ctx, points, lineOpacity) {\n    ctx.beginPath()\n    this._arc(ctx, points, lineOpacity)\n    Canvas2d._stroke(ctx, lineOpacity)\n    this._paintArrow(ctx, points, lineOpacity)\n  }\n\n  static fromJSON (json) {\n    const feature = json['feature']\n    const arc = new Curve(feature['geometry']['coordinates'], json['options'])\n    arc.setProperties(feature['properties'])\n    return arc\n  }\n}\nCurve.registerJSONType('Curve')\nCurve.mergeOptions(options)\n\nexport default Curve\n","import * as maptalks from 'maptalks'\nconst Coordinate = maptalks.Coordinate\nconst options = {\n  'arrowStyle': null,\n  'arrowPlacement': 'vertex-last', // vertex-first, vertex-last, vertex-firstlast, point\n  'clipToPaint': true\n}\n\nclass Polyline extends maptalks.LineString {\n  constructor (coordinates, options = {}) {\n    super(options)\n    this.type = 'Polyline'\n    if (coordinates) {\n      this.setCoordinates(coordinates)\n    }\n  }\n\n  _exportGeoJSONGeometry () {\n    const points = this.getCoordinates()\n    const coordinates = Coordinate.toNumberArrays(points)\n    return {\n      'type': 'LineString',\n      'coordinates': coordinates\n    }\n  }\n\n  _toJSON (options) {\n    return {\n      'feature': this.toGeoJSON(options)\n    }\n  }\n}\n\nPolyline.mergeOptions(options)\n\nPolyline.registerJSONType('Polyline')\n\nexport default Polyline\n","/**\n * Created by FDD on 2017/12/12.\n * @desc 自由线\n * @Inherits maptalks.LineString\n */\nimport * as maptalks from 'maptalks'\nconst Coordinate = maptalks.Coordinate\nconst options = {\n  'arrowStyle': null,\n  'arrowPlacement': 'vertex-last', // vertex-first, vertex-last, vertex-firstlast, point\n  'clipToPaint': true\n}\n\nclass FreeLine extends maptalks.LineString {\n  constructor (coordinates, options = {}) {\n    super(options)\n    this.type = 'FreeLine'\n    if (coordinates) {\n      this.setCoordinates(coordinates)\n    }\n  }\n\n  _exportGeoJSONGeometry () {\n    const points = this.getCoordinates()\n    const coordinates = Coordinate.toNumberArrays(points)\n    return {\n      'type': 'LineString',\n      'coordinates': coordinates\n    }\n  }\n\n  _toJSON (options) {\n    return {\n      'feature': this.toGeoJSON(options)\n    }\n  }\n}\n\nFreeLine.mergeOptions(options)\n\nFreeLine.registerJSONType('FreeLine')\n\nexport default FreeLine\n","/**\n * Created by FDD on 2017/5/20.\n * @desc 标绘图形构造类\n */\n\nimport Curve from './Polyline/Curve'\nimport Polyline from './Polyline/Polyline'\nimport FreeLine from './Polyline/FreeLine'\nimport * as PlotTypes from '../core/PlotTypes'\nconst RegisterModes = {}\nRegisterModes[PlotTypes.CURVE] = {\n  'action': 'clickDblclick',\n  'create': function (path) {\n    return new Curve(path)\n  },\n  'update': function (path, geometry) {\n    geometry.setCoordinates(path)\n  },\n  'generate': function (geometry) {\n    return geometry\n  }\n}\nRegisterModes[PlotTypes.POLYLINE] = {\n  'action': 'clickDblclick',\n  'create': function (path) {\n    return new Polyline(path)\n  },\n  'update': function (path, geometry) {\n    geometry.setCoordinates(path)\n  },\n  'generate': function (geometry) {\n    return geometry\n  }\n}\nRegisterModes[PlotTypes.FREE_LINE] = {\n  'action': 'click',\n  'create': function (path) {\n    return new FreeLine(path)\n  },\n  'update': function (path, geometry) {\n    geometry.setCoordinates(path)\n  },\n  'generate': function (geometry) {\n    return geometry\n  }\n}\n\nexport default RegisterModes\n","import * as Constants from '../Constants'\n/**\n * 计算两个坐标之间的距离\n * @param pnt1\n * @param pnt2\n * @returns {number}\n * @constructor\n */\nexport const MathDistance = (pnt1, pnt2) => {\n  return (Math.sqrt(Math.pow((pnt1[0] - pnt2[0]), 2) + Math.pow((pnt1[1] - pnt2[1]), 2)))\n}\n\n/**\n * 计算点集合的总距离\n * @param points\n * @returns {number}\n */\nexport const wholeDistance = (points) => {\n  let distance = 0\n  if (points && Array.isArray(points) && points.length > 0) {\n    points.forEach((item, index) => {\n      if (index < points.length - 1) {\n        distance += (MathDistance(item, points[index + 1]))\n      }\n    })\n  }\n  return distance\n}\n/**\n * 获取基础长度\n * @param points\n * @returns {number}\n */\nexport const getBaseLength = (points) => {\n  return Math.pow(wholeDistance(points), 0.99)\n}\n\n/**\n * 求取两个坐标的中间值\n * @param point1\n * @param point2\n * @returns {[*,*]}\n * @constructor\n */\nexport const Mid = (point1, point2) => {\n  return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2]\n}\n\n/**\n * 通过三个点确定一个圆的中心点\n * @param point1\n * @param point2\n * @param point3\n */\nexport const getCircleCenterOfThreePoints = (point1, point2, point3) => {\n  let pntA = [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2]\n  let pntB = [pntA[0] - point1[1] + point2[1], pntA[1] + point1[0] - point2[0]]\n  let pntC = [(point1[0] + point3[0]) / 2, (point1[1] + point3[1]) / 2]\n  let pntD = [pntC[0] - point1[1] + point3[1], pntC[1] + point1[0] - point3[0]]\n  return getIntersectPoint(pntA, pntB, pntC, pntD)\n}\n\n/**\n * 获取交集的点\n * @param pntA\n * @param pntB\n * @param pntC\n * @param pntD\n * @returns {[*,*]}\n */\nexport const getIntersectPoint = (pntA, pntB, pntC, pntD) => {\n  if (pntA[1] === pntB[1]) {\n    let f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1])\n    let x = f * (pntA[1] - pntC[1]) + pntC[0]\n    let y = pntA[1]\n    return [x, y]\n  }\n  if (pntC[1] === pntD[1]) {\n    let e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1])\n    let x = e * (pntC[1] - pntA[1]) + pntA[0]\n    let y = pntC[1]\n    return [x, y]\n  }\n  let e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1])\n  let f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1])\n  let y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f)\n  let x = e * y - e * pntA[1] + pntA[0]\n  return [x, y]\n}\n\n/**\n * 获取方位角（地平经度）\n * @param startPoint\n * @param endPoint\n * @returns {*}\n */\nexport const getAzimuth = (startPoint, endPoint) => {\n  let azimuth\n  let angle = Math.asin(Math.abs(endPoint[1] - startPoint[1]) / (MathDistance(startPoint, endPoint)))\n  if (endPoint[1] >= startPoint[1] && endPoint[0] >= startPoint[0]) {\n    azimuth = angle + Math.PI\n  } else if (endPoint[1] >= startPoint[1] && endPoint[0] < startPoint[0]) {\n    azimuth = Math.PI * 2 - angle\n  } else if (endPoint[1] < startPoint[1] && endPoint[0] < startPoint[0]) {\n    azimuth = angle\n  } else if (endPoint[1] < startPoint[1] && endPoint[0] >= startPoint[0]) {\n    azimuth = Math.PI - angle\n  }\n  return azimuth\n}\n\n/**\n * 通过三个点获取方位角\n * @param pntA\n * @param pntB\n * @param pntC\n * @returns {number}\n */\nexport const getAngleOfThreePoints = (pntA, pntB, pntC) => {\n  let angle = getAzimuth(pntB, pntA) - getAzimuth(pntB, pntC)\n  return ((angle < 0) ? (angle + Math.PI * 2) : angle)\n}\n\n/**\n * 判断是否是顺时针\n * @param pnt1\n * @param pnt2\n * @param pnt3\n * @returns {boolean}\n */\nexport const isClockWise = (pnt1, pnt2, pnt3) => {\n  return ((pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]))\n}\n\n/**\n * 获取线上的点\n * @param t\n * @param startPnt\n * @param endPnt\n * @returns {[*,*]}\n */\nexport const getPointOnLine = (t, startPnt, endPnt) => {\n  let x = startPnt[0] + (t * (endPnt[0] - startPnt[0]))\n  let y = startPnt[1] + (t * (endPnt[1] - startPnt[1]))\n  return [x, y]\n}\n\n/**\n * 获取立方值\n * @param t\n * @param startPnt\n * @param cPnt1\n * @param cPnt2\n * @param endPnt\n * @returns {[*,*]}\n */\nexport const getCubicValue = (t, startPnt, cPnt1, cPnt2, endPnt) => {\n  t = Math.max(Math.min(t, 1), 0)\n  let [tp, t2] = [(1 - t), (t * t)]\n  let t3 = t2 * t\n  let tp2 = tp * tp\n  let tp3 = tp2 * tp\n  let x = (tp3 * startPnt[0]) + (3 * tp2 * t * cPnt1[0]) + (3 * tp * t2 * cPnt2[0]) + (t3 * endPnt[0])\n  let y = (tp3 * startPnt[1]) + (3 * tp2 * t * cPnt1[1]) + (3 * tp * t2 * cPnt2[1]) + (t3 * endPnt[1])\n  return [x, y]\n}\n\n/**\n * 根据起止点和旋转方向求取第三个点\n * @param startPnt\n * @param endPnt\n * @param angle\n * @param distance\n * @param clockWise\n * @returns {[*,*]}\n */\nexport const getThirdPoint = (startPnt, endPnt, angle, distance, clockWise) => {\n  let azimuth = getAzimuth(startPnt, endPnt)\n  let alpha = clockWise ? (azimuth + angle) : (azimuth - angle)\n  let dx = distance * Math.cos(alpha)\n  let dy = distance * Math.sin(alpha)\n  return ([endPnt[0] + dx, endPnt[1] + dy])\n}\n\n/**\n * 插值弓形线段点\n * @param center\n * @param radius\n * @param startAngle\n * @param endAngle\n * @returns {null}\n */\nexport const getArcPoints = (center, radius, startAngle, endAngle) => {\n  let [x, y, pnts, angleDiff] = [null, null, [], (endAngle - startAngle)]\n  angleDiff = ((angleDiff < 0) ? (angleDiff + (Math.PI * 2)) : angleDiff)\n  for (let i = 0; i <= 100; i++) {\n    let angle = startAngle + angleDiff * i / 100\n    x = center[0] + radius * Math.cos(angle)\n    y = center[1] + radius * Math.sin(angle)\n    pnts.push([x, y])\n  }\n  return pnts\n}\n\n/**\n * getBisectorNormals\n * @param t\n * @param pnt1\n * @param pnt2\n * @param pnt3\n * @returns {[*,*]}\n */\nexport const getBisectorNormals = (t, pnt1, pnt2, pnt3) => {\n  let normal = getNormal(pnt1, pnt2, pnt3)\n  let [bisectorNormalRight, bisectorNormalLeft, dt, x, y] = [null, null, null, null, null]\n  let dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1])\n  let uX = normal[0] / dist\n  let uY = normal[1] / dist\n  let d1 = MathDistance(pnt1, pnt2)\n  let d2 = MathDistance(pnt2, pnt3)\n  if (dist > Constants.ZERO_TOLERANCE) {\n    if (isClockWise(pnt1, pnt2, pnt3)) {\n      dt = t * d1\n      x = pnt2[0] - dt * uY\n      y = pnt2[1] + dt * uX\n      bisectorNormalRight = [x, y]\n      dt = t * d2\n      x = pnt2[0] + dt * uY\n      y = pnt2[1] - dt * uX\n      bisectorNormalLeft = [x, y]\n    } else {\n      dt = t * d1\n      x = pnt2[0] + dt * uY\n      y = pnt2[1] - dt * uX\n      bisectorNormalRight = [x, y]\n      dt = t * d2\n      x = pnt2[0] - dt * uY\n      y = pnt2[1] + dt * uX\n      bisectorNormalLeft = [x, y]\n    }\n  } else {\n    x = pnt2[0] + t * (pnt1[0] - pnt2[0])\n    y = pnt2[1] + t * (pnt1[1] - pnt2[1])\n    bisectorNormalRight = [x, y]\n    x = pnt2[0] + t * (pnt3[0] - pnt2[0])\n    y = pnt2[1] + t * (pnt3[1] - pnt2[1])\n    bisectorNormalLeft = [x, y]\n  }\n  return [bisectorNormalRight, bisectorNormalLeft]\n}\n\n/**\n * 获取默认三点的内切圆\n * @param pnt1\n * @param pnt2\n * @param pnt3\n * @returns {[*,*]}\n */\nexport const getNormal = (pnt1, pnt2, pnt3) => {\n  let dX1 = pnt1[0] - pnt2[0]\n  let dY1 = pnt1[1] - pnt2[1]\n  let d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1)\n  dX1 /= d1\n  dY1 /= d1\n  let dX2 = pnt3[0] - pnt2[0]\n  let dY2 = pnt3[1] - pnt2[1]\n  let d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2)\n  dX2 /= d2\n  dY2 /= d2\n  let uX = dX1 + dX2\n  let uY = dY1 + dY2\n  return [uX, uY]\n}\n\n/**\n * 获取左边控制点\n * @param controlPoints\n * @returns {[*,*]}\n */\nexport const getLeftMostControlPoint = (controlPoints, t) => {\n  let [pnt1, pnt2, pnt3, controlX, controlY] = [controlPoints[0], controlPoints[1], controlPoints[2], null, null]\n  let pnts = getBisectorNormals(0, pnt1, pnt2, pnt3)\n  let normalRight = pnts[0]\n  let normal = getNormal(pnt1, pnt2, pnt3)\n  let dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1])\n  if (dist > Constants.ZERO_TOLERANCE) {\n    let mid = Mid(pnt1, pnt2)\n    let pX = pnt1[0] - mid[0]\n    let pY = pnt1[1] - mid[1]\n    let d1 = MathDistance(pnt1, pnt2)\n    let n = 2.0 / d1\n    let nX = -n * pY\n    let nY = n * pX\n    let a11 = nX * nX - nY * nY\n    let a12 = 2 * nX * nY\n    let a22 = nY * nY - nX * nX\n    let dX = normalRight[0] - mid[0]\n    let dY = normalRight[1] - mid[1]\n    controlX = mid[0] + a11 * dX + a12 * dY\n    controlY = mid[1] + a12 * dX + a22 * dY\n  } else {\n    controlX = pnt1[0] + t * (pnt2[0] - pnt1[0])\n    controlY = pnt1[1] + t * (pnt2[1] - pnt1[1])\n  }\n  return [controlX, controlY]\n}\n\n/**\n * 获取右边控制点\n * @param controlPoints\n * @param t\n * @returns {[*,*]}\n */\nexport const getRightMostControlPoint = (controlPoints, t) => {\n  let count = controlPoints.length\n  let pnt1 = controlPoints[count - 3]\n  let pnt2 = controlPoints[count - 2]\n  let pnt3 = controlPoints[count - 1]\n  let pnts = getBisectorNormals(0, pnt1, pnt2, pnt3)\n  let normalLeft = pnts[1]\n  let normal = getNormal(pnt1, pnt2, pnt3)\n  let dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1])\n  let [controlX, controlY] = [null, null]\n  if (dist > Constants.ZERO_TOLERANCE) {\n    let mid = Mid(pnt2, pnt3)\n    let pX = pnt3[0] - mid[0]\n    let pY = pnt3[1] - mid[1]\n    let d1 = MathDistance(pnt2, pnt3)\n    let n = 2.0 / d1\n    let nX = -n * pY\n    let nY = n * pX\n    let a11 = nX * nX - nY * nY\n    let a12 = 2 * nX * nY\n    let a22 = nY * nY - nX * nX\n    let dX = normalLeft[0] - mid[0]\n    let dY = normalLeft[1] - mid[1]\n    controlX = mid[0] + a11 * dX + a12 * dY\n    controlY = mid[1] + a12 * dX + a22 * dY\n  } else {\n    controlX = pnt3[0] + t * (pnt2[0] - pnt3[0])\n    controlY = pnt3[1] + t * (pnt2[1] - pnt3[1])\n  }\n  return [controlX, controlY]\n}\n\n/**\n * 插值曲线点\n * @param t\n * @param controlPoints\n * @returns {null}\n */\nexport const getCurvePoints = (t, controlPoints) => {\n  let leftControl = getLeftMostControlPoint(controlPoints, t)\n  let [pnt1, pnt2, pnt3, normals, points] = [null, null, null, [leftControl], []]\n  for (let i = 0; i < controlPoints.length - 2; i++) {\n    [pnt1, pnt2, pnt3] = [controlPoints[i], controlPoints[i + 1], controlPoints[i + 2]]\n    let normalPoints = getBisectorNormals(t, pnt1, pnt2, pnt3)\n    normals = normals.concat(normalPoints)\n  }\n  let rightControl = getRightMostControlPoint(controlPoints, t)\n  if (rightControl) {\n    normals.push(rightControl)\n  }\n  for (let i = 0; i < controlPoints.length - 1; i++) {\n    pnt1 = controlPoints[i]\n    pnt2 = controlPoints[i + 1]\n    points.push(pnt1)\n    for (let t = 0; t < Constants.FITTING_COUNT; t++) {\n      let pnt = getCubicValue(t / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2)\n      points.push(pnt)\n    }\n    points.push(pnt2)\n  }\n  return points\n}\n\n/**\n * 贝塞尔曲线\n * @param points\n * @returns {*}\n */\nexport const getBezierPoints = function (points) {\n  if (points.length <= 2) {\n    return points\n  } else {\n    let bezierPoints = []\n    let n = points.length - 1\n    for (let t = 0; t <= 1; t += 0.01) {\n      let [x, y] = [0, 0]\n      for (let index = 0; index <= n; index++) {\n        let factor = getBinomialFactor(n, index)\n        let a = Math.pow(t, index)\n        let b = Math.pow((1 - t), (n - index))\n        x += factor * a * b * points[index][0]\n        y += factor * a * b * points[index][1]\n      }\n      bezierPoints.push([x, y])\n    }\n    bezierPoints.push(points[n])\n    return bezierPoints\n  }\n}\n\n/**\n * 获取阶乘数据\n * @param n\n * @returns {number}\n */\nexport const getFactorial = (n) => {\n  let result = 1\n  switch (n) {\n    case (n <= 1):\n      result = 1\n      break\n    case (n === 2):\n      result = 2\n      break\n    case (n === 3):\n      result = 6\n      break\n    case (n === 24):\n      result = 24\n      break\n    case (n === 5):\n      result = 120\n      break\n    default:\n      for (let i = 1; i <= n; i++) {\n        result *= i\n      }\n      break\n  }\n  return result\n}\n\n/**\n * 获取二项分布\n * @param n\n * @param index\n * @returns {number}\n */\nexport const getBinomialFactor = (n, index) => {\n  return (getFactorial(n) / (getFactorial(index) * getFactorial(n - index)))\n}\n\n/**\n * 插值线性点\n * @param points\n * @returns {*}\n */\nexport const getQBSplinePoints = points => {\n  if (points.length <= 2) {\n    return points\n  } else {\n    let [n, bSplinePoints] = [2, []]\n    let m = points.length - n - 1\n    bSplinePoints.push(points[0])\n    for (let i = 0; i <= m; i++) {\n      for (let t = 0; t <= 1; t += 0.05) {\n        let [x, y] = [0, 0]\n        for (let k = 0; k <= n; k++) {\n          let factor = getQuadricBSplineFactor(k, t)\n          x += factor * points[i + k][0]\n          y += factor * points[i + k][1]\n        }\n        bSplinePoints.push([x, y])\n      }\n    }\n    bSplinePoints.push(points[points.length - 1])\n    return bSplinePoints\n  }\n}\n\n/**\n * 得到二次线性因子\n * @param k\n * @param t\n * @returns {number}\n */\nexport const getQuadricBSplineFactor = (k, t) => {\n  let res = 0\n  if (k === 0) {\n    res = Math.pow(t - 1, 2) / 2\n  } else if (k === 1) {\n    res = (-2 * Math.pow(t, 2) + 2 * t + 1) / 2\n  } else if (k === 2) {\n    res = Math.pow(t, 2) / 2\n  }\n  return res\n}\n\n/**\n * 判断是否为对象\n * @param value\n * @returns {boolean}\n */\nexport const isObject = value => {\n  const type = typeof value\n  return value !== null && (type === 'object' || type === 'function')\n}\n\nexport const merge = (a, b) => {\n  for (const key in b) {\n    if (isObject(b[key]) && isObject(a[key])) {\n      merge(a[key], b[key])\n    } else {\n      a[key] = b[key]\n    }\n  }\n  return a\n}\n","/**\n * Created by FDD on 2017/12/10.\n * @desc PlotDraw\n */\n\nimport * as maptalks from 'maptalks'\nimport RegisterModes from '../geometry'\nimport { merge } from '../utils/utils'\nconst Polygon = maptalks.Polygon\nconst _options = {\n  'symbol': {\n    'lineColor': '#000',\n    'lineWidth': 2,\n    'lineOpacity': 1,\n    'polygonFill': '#fff',\n    'polygonOpacity': 0.3\n  },\n  'doubleClickZoom': false,\n  'mode': null,\n  'once': false,\n  'ignoreMouseleave': true\n}\nconst registeredMode = {}\nclass PlotDraw extends maptalks.DrawTool {\n  constructor (options = {}) {\n    const $options = merge(_options, options)\n    super($options)\n    this.options = $options\n    this._checkMode()\n  }\n\n  _getRegisterMode () {\n    const mode = this.getMode()\n    const registerMode = PlotDraw.getRegisterMode(mode)\n    if (!registerMode) {\n      throw new Error(mode + ' is not a valid mode of DrawTool.')\n    }\n    return registerMode\n  }\n\n  /**\n   * Set draw tool's symbol\n   * @param {Object} symbol - symbol set\n   * @returns {DrawTool} this\n   */\n  setSymbol (symbol) {\n    if (!symbol) {\n      return this\n    }\n    this.options['symbol'] = symbol\n    if (this._geometry) {\n      this._geometry.setSymbol(symbol)\n    }\n    return this\n  }\n\n  /**\n   * click fro path\n   * @param param\n   * @private\n   */\n  _clickForPath (param) {\n    const registerMode = this._getRegisterMode()\n    const coordinate = param['coordinate']\n    const symbol = this.getSymbol()\n    if (!this._geometry) {\n      this._clickCoords = [coordinate]\n      this._geometry = registerMode['create'](this._clickCoords, param)\n      if (symbol) {\n        this._geometry.setSymbol(symbol)\n      }\n      this._addGeometryToStage(this._geometry)\n\n      /**\n       * drawstart event.\n       */\n      this._fireEvent('drawstart', param)\n    } else {\n      if (!(this._historyPointer === null)) {\n        this._clickCoords = this._clickCoords.slice(0, this._historyPointer)\n      }\n      this._clickCoords.push(coordinate)\n      this._historyPointer = this._clickCoords.length\n      registerMode['update'](this._clickCoords, this._geometry, param)\n\n      /**\n       * drawvertex event.\n       */\n      this._fireEvent('drawvertex', param)\n    }\n  }\n\n  /**\n   * mouse move fro path\n   * @param param\n   * @private\n   */\n  _mousemoveForPath (param) {\n    const map = this.getMap()\n    if (!this._geometry || !map || map.isInteracting()) {\n      return\n    }\n    const containerPoint = this._getMouseContainerPoint(param)\n    if (!this._isValidContainerPoint(containerPoint)) {\n      return\n    }\n    const coordinate = param['coordinate']\n    const registerMode = this._getRegisterMode()\n    const path = this._clickCoords.slice(0, this._historyPointer)\n    if (path && path.length > 0 && coordinate.equals(path[path.length - 1])) {\n      return\n    }\n    registerMode['update'](path.concat([coordinate]), this._geometry, param)\n\n    /**\n     * mousemove event\n     */\n    this._fireEvent('mousemove', param)\n  }\n\n  /**\n   * dbclick fro path\n   * @param param\n   * @private\n   */\n  _dblclickForPath (param) {\n    if (!this._geometry) {\n      return\n    }\n    const containerPoint = this._getMouseContainerPoint(param)\n    if (!this._isValidContainerPoint(containerPoint)) {\n      return\n    }\n    const registerMode = this._getRegisterMode()\n    const coordinate = param['coordinate']\n    const path = this._clickCoords\n    path.push(coordinate)\n    if (path.length < 2) {\n      return\n    }\n    // 去除重复的端点\n    const nIndexes = []\n    for (let i = 1, len = path.length; i < len; i++) {\n      if (path[i].x === path[i - 1].x && path[i].y === path[i - 1].y) {\n        nIndexes.push(i)\n      }\n    }\n    for (let i = nIndexes.length - 1; i >= 0; i--) {\n      path.splice(nIndexes[i], 1)\n    }\n\n    if (path.length < 2 || (this._geometry && (this._geometry instanceof Polygon) && path.length < 3)) {\n      return\n    }\n    registerMode['update'](path, this._geometry, param)\n    this.endDraw(param)\n  }\n\n  /**\n   * when nousedown start draw geometry\n   * @param param\n   * @returns {boolean}\n   * @private\n   */\n  _mousedownToDraw (param) {\n    const map = this._map\n    const registerMode = this._getRegisterMode()\n    const me = this\n    const firstPoint = this._getMouseContainerPoint(param)\n    if (!this._isValidContainerPoint(firstPoint)) {\n      return false\n    }\n\n    function genGeometry (evt) {\n      const symbol = me.getSymbol()\n      let geometry = me._geometry\n      if (!geometry) {\n        geometry = registerMode['create'](evt.coordinate, evt)\n        geometry.setSymbol(symbol)\n        me._addGeometryToStage(geometry)\n        me._geometry = geometry\n      } else {\n        registerMode['update'](evt.coordinate, geometry, evt)\n      }\n    }\n\n    /**\n     * handle mouse move\n     * @param evt\n     * @returns {boolean}\n     */\n    const onMouseMove = function (evt) {\n      if (!this._geometry) {\n        return false\n      }\n      const current = this._getMouseContainerPoint(evt)\n      if (!this._isValidContainerPoint(current)) {\n        return false\n      }\n      genGeometry(evt)\n      this._fireEvent('mousemove', param)\n      return false\n    }\n\n    /**\n     * handle mouse up\n     * @param evt\n     * @returns {boolean}\n     */\n    const onMouseUp = function (evt) {\n      map.off('mousemove', onMouseMove, this)\n      map.off('mouseup', onMouseUp, this)\n      if (!this.options['ignoreMouseleave']) {\n        map.off('mouseleave', onMouseUp, this)\n      }\n      if (!this._geometry) {\n        return false\n      }\n      const current = this._getMouseContainerPoint(evt)\n      if (this._isValidContainerPoint(current)) {\n        genGeometry(evt)\n      }\n      this.endDraw(param)\n      return false\n    }\n\n    this._fireEvent('drawstart', param)\n    genGeometry(param)\n    map.on('mousemove', onMouseMove, this)\n    map.on('mouseup', onMouseUp, this)\n    if (!this.options['ignoreMouseleave']) {\n      map.on('mouseleave', onMouseUp, this)\n    }\n    return false\n  }\n\n  /**\n   * get register events\n   * @returns {*}\n   */\n  getEvents () {\n    const action = this._getRegisterMode()['action']\n    if (action === 'clickDblclick') {\n      return {\n        'click': this._clickForPath,\n        'mousemove': this._mousemoveForPath,\n        'dblclick': this._dblclickForPath\n      }\n    } else if (action === 'click') {\n      return {\n        'click': this._clickForPoint\n      }\n    } else if (action === 'drag') {\n      return {\n        'mousedown': this._mousedownToDraw\n      }\n    }\n    return null\n  }\n\n  /**\n   * Register a new mode for DrawTool\n   * @param name\n   * @param modeAction\n   */\n  static registerMode (name, modeAction) {\n    registeredMode[name.toLowerCase()] = modeAction\n  }\n\n  /**\n   * Get mode actions by mode name\n   * @param  {String} name DrawTool mode name\n   * @return {Object}      mode actions\n   */\n  static getRegisterMode (name) {\n    return registeredMode[name.toLowerCase()]\n  }\n\n  /**\n   * Register modes for DrawTool\n   * @param modes\n   */\n  static registeredModes (modes) {\n    if (modes) {\n      for (let key of Reflect.ownKeys(modes)) {\n        if (!key.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)) {\n          let desc = Object.getOwnPropertyDescriptor(modes, key)\n          let _key = key.toLowerCase()\n          Object.defineProperty(registeredMode, _key, desc)\n          console.log(registeredMode)\n        }\n      }\n    }\n  }\n}\n\nPlotDraw.registeredModes(RegisterModes)\n\nexport default PlotDraw\n"],"names":["TextArea","ARC","CURVE","GATHERING_PLACE","POLYLINE","FREE_LINE","POINT","PENNANT","RECTANGLE","CIRCLE","ELLIPSE","LUNE","SECTOR","CLOSED_CURVE","POLYGON","FREE_POLYGON","ATTACK_ARROW","DOUBLE_ARROW","STRAIGHT_ARROW","FINE_ARROW","ASSAULT_DIRECTION","TAILED_ATTACK_ARROW","SQUAD_COMBAT","TAILED_SQUAD_COMBAT","RECTFLAG","TRIANGLEFLAG","CURVEFLAG","Canvas2d","maptalks","options","Curve","_arc","ctx","points","lineOpacity","degree","Math","PI","i","l","length","_arcBetween","_stroke","_quadraticCurve","_path","quadraticCurve","_bezierCurve","bezierCurveTo","x","y","lineTo","_toJSON","toGeoJSON","_paintOn","beginPath","_paintArrow","fromJSON","json","feature","arc","setProperties","registerJSONType","mergeOptions","Coordinate","Polyline","coordinates","type","setCoordinates","_exportGeoJSONGeometry","getCoordinates","toNumberArrays","FreeLine","RegisterModes","PlotTypes","path","geometry","isObject","value","merge","a","b","key","Polygon","_options","registeredMode","PlotDraw","$options","_checkMode","_getRegisterMode","mode","getMode","registerMode","getRegisterMode","Error","setSymbol","symbol","_geometry","_clickForPath","param","coordinate","getSymbol","_clickCoords","_addGeometryToStage","_fireEvent","_historyPointer","slice","push","_mousemoveForPath","map","getMap","isInteracting","containerPoint","_getMouseContainerPoint","_isValidContainerPoint","equals","concat","_dblclickForPath","nIndexes","len","splice","endDraw","_mousedownToDraw","_map","me","firstPoint","genGeometry","evt","onMouseMove","current","onMouseUp","off","on","getEvents","action","_clickForPoint","name","modeAction","toLowerCase","registeredModes","modes","Reflect","ownKeys","match","desc","Object","getOwnPropertyDescriptor","_key","defineProperty","log"],"mappings":"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"}